(window.webpackJsonp=window.webpackJsonp||[]).push([[156],{561:function(a,t,e){"use strict";e.r(t);var n=e(42),r=Object(n.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"jvm工具"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm工具"}},[a._v("#")]),a._v(" JVM工具")]),a._v(" "),e("h2",{attrs:{id:"jstat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jstat"}},[a._v("#")]),a._v(" jstat")]),a._v(" "),e("p",[a._v("查看"),e("code",[a._v("堆内存")]),a._v("各部分的使用量，以及加载类的数量。")]),a._v(" "),e("p",[a._v("命令格式如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]\n")])])]),e("p",[a._v("以下转载了网上常用的统计命令")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/maosijunzi/article/details/46049117",target:"_blank",rel:"noopener noreferrer"}},[a._v("原文地址"),e("OutboundLink")],1)]),a._v(" "),e("h3",{attrs:{id:"类加载统计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类加载统计"}},[a._v("#")]),a._v(" 类加载统计")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("jstat -class {pid}\n")])])]),e("p",[a._v("Loaded:加载class的数量\nBytes：所占用空间大小\nUnloaded：未加载数量\nBytes:未加载占用空间\nTime：时间")]),a._v(" "),e("h3",{attrs:{id:"编译统计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编译统计"}},[a._v("#")]),a._v(" 编译统计")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("jstat -compiler {pid}\n")])])]),e("p",[a._v("Compiled：编译数量。\nFailed：失败数量\nInvalid：不可用数量\nTime：时间\nFailedType：失败类型\nFailedMethod：失败的方法")]),a._v(" "),e("h3",{attrs:{id:"垃圾回收统计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收统计"}},[a._v("#")]),a._v(" 垃圾回收统计")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("jstat -gc {pid}\n")])])]),e("p",[a._v("S0C：第一个幸存区的大小\nS1C：第二个幸存区的大小\nS0U：第一个幸存区的使用大小\nS1U：第二个幸存区的使用大小\nEC：伊甸园区的大小\nEU：伊甸园区的使用大小\nOC：老年代大小\nOU：老年代使用大小\nMC：方法区大小\nMU：方法区使用大小\nCCSC:压缩类空间大小\nCCSU:压缩类空间使用大小\nYGC：年轻代垃圾回收次数\nYGCT：年轻代垃圾回收消耗时间\nFGC：老年代垃圾回收次数\nFGCT：老年代垃圾回收消耗时间\nGCT：垃圾回收消耗总时间")]),a._v(" "),e("h3",{attrs:{id:"堆内存统计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#堆内存统计"}},[a._v("#")]),a._v(" 堆内存统计")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("jstat -gccapacity {pid}\n")])])]),e("p",[a._v("NGCMN：新生代最小容量\nNGCMX：新生代最大容量\nNGC：当前新生代容量\nS0C：第一个幸存区大小\nS1C：第二个幸存区的大小\nEC：伊甸园区的大小\nOGCMN：老年代最小容量\nOGCMX：老年代最大容量\nOGC：当前老年代大小\nOC:当前老年代大小\nMCMN:最小元数据容量\nMCMX：最大元数据容量\nMC：当前元数据空间大小\nCCSMN：最小压缩类空间大小\nCCSMX：最大压缩类空间大小\nCCSC：当前压缩类空间大小\nYGC：年轻代gc次数\nFGC：老年代GC次数")]),a._v(" "),e("h3",{attrs:{id:"新生代垃圾回收统计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#新生代垃圾回收统计"}},[a._v("#")]),a._v(" 新生代垃圾回收统计")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("jstat -gcnew {pid}\n")])])]),e("p",[a._v("S0C：第一个幸存区大小\nS1C：第二个幸存区的大小\nS0U：第一个幸存区的使用大小\nS1U：第二个幸存区的使用大小\nTT:对象在新生代存活的次数\nMTT:对象在新生代存活的最大次数\nDSS:期望的幸存区大小\nEC：伊甸园区的大小\nEU：伊甸园区的使用大小\nYGC：年轻代垃圾回收次数\nYGCT：年轻代垃圾回收消耗时间")]),a._v(" "),e("h3",{attrs:{id:"新生代内存统计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#新生代内存统计"}},[a._v("#")]),a._v(" 新生代内存统计")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("jstat -gcnewcapacity {pid}\n")])])]),e("p",[a._v("NGCMN：新生代最小容量\nNGCMX：新生代最大容量\nNGC：当前新生代容量\nS0CMX：最大幸存1区大小\nS0C：当前幸存1区大小\nS1CMX：最大幸存2区大小\nS1C：当前幸存2区大小\nECMX：最大伊甸园区大小\nEC：当前伊甸园区大小\nYGC：年轻代垃圾回收次数\nFGC：老年代回收次数")]),a._v(" "),e("h3",{attrs:{id:"老年代内存统计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#老年代内存统计"}},[a._v("#")]),a._v(" 老年代内存统计")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("jstat -gcoldcapacity {pid}\n")])])]),e("p",[a._v("OGCMN：老年代最小容量\nOGCMX：老年代最大容量\nOGC：当前老年代大小\nOC：老年代大小\nYGC：年轻代垃圾回收次数\nFGC：老年代垃圾回收次数\nFGCT：老年代垃圾回收消耗时间\nGCT：垃圾回收消耗总时间")]),a._v(" "),e("h3",{attrs:{id:"元数据空间统计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#元数据空间统计"}},[a._v("#")]),a._v(" 元数据空间统计")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("jstat -gcmetacapacity {pid}\n")])])]),e("p",[a._v("MCMN:最小元数据容量\nMCMX：最大元数据容量\nMC：当前元数据空间大小\nCCSMN：最小压缩类空间大小\nCCSMX：最大压缩类空间大小\nCCSC：当前压缩类空间大小\nYGC：年轻代垃圾回收次数\nFGC：老年代垃圾回收次数\nFGCT：老年代垃圾回收消耗时间\nGCT：垃圾回收消耗总时间")]),a._v(" "),e("h3",{attrs:{id:"总结垃圾回收统计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结垃圾回收统计"}},[a._v("#")]),a._v(" 总结垃圾回收统计")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("jstat -gcutil {pid}\n")])])]),e("p",[a._v("S0：幸存1区当前使用比例\nS1：幸存2区当前使用比例\nE：伊甸园区使用比例\nO：老年代使用比例\nM：元数据区使用比例\nCCS：压缩使用比例\nYGC：年轻代垃圾回收次数\nFGC：老年代垃圾回收次数\nFGCT：老年代垃圾回收消耗时间\nGCT：垃圾回收消耗总时间")]),a._v(" "),e("h3",{attrs:{id:"jvm编译方法统计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm编译方法统计"}},[a._v("#")]),a._v(" JVM编译方法统计")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("jstat -printcompilation {pid}\n")])])]),e("p",[a._v("Compiled：最近编译方法的数量\nSize：最近编译方法的字节码数量\nType：最近编译方法的编译类型。\nMethod：方法名标识。")]),a._v(" "),e("h2",{attrs:{id:"jstack"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jstack"}},[a._v("#")]),a._v(" jstack")]),a._v(" "),e("p",[a._v("jstack用于生成java虚拟机当前时刻的线程快照。")]),a._v(" "),e("p",[e("strong",[a._v("jstack能排查什么问题？")])]),a._v(" "),e("ol",[e("li",[a._v("线程出现长时间停顿（线程间死锁、死循环、请求外部资源导致的长时间等待）")]),a._v(" "),e("li",[a._v("排查线程阻塞")]),a._v(" "),e("li",[a._v("排查资源耗尽问题（等网络读写、等待数据IO）")])]),a._v(" "),e("p",[e("strong",[a._v("线程在堆栈中的状态有：")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("NEW,未启动的。不会出现在Dump中。\n\nRUNNABLE,在虚拟机内执行的。\n\nBLOCKED,受阻塞并等待监视器锁。\n\nWATING,无限期等待另一个线程执行特定操作。\n\nTIMED_WATING,有时限的等待另一个线程的特定操作。\n\nTERMINATED,已退出的。\n")])])]),e("p",[e("strong",[a._v("堆栈中用于修饰方法调用的内容有：")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("locked <地址> 目标：使用synchronized申请对象锁成功,监视器的拥有者。\n\nwaiting to lock <地址> 目标：使用synchronized申请对象锁未成功,在迚入区等待。\n\nwaiting on <地址> 目标：使用synchronized申请对象锁成功后,释放锁幵在等待区等待。\n\nparking to wait for <地址> 目标\n")])])]),e("p",[e("strong",[a._v("堆栈案例解读：")])]),a._v(" "),e("p",[a._v("下面列举了一个jstack打印的堆栈信息，并且附有内容释义。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('"http-nio-40243-exec-393" #1212 daemon prio=5 os_prio=0 tid=0x00007f4fdc3d9000 nid=0xe30 runnable [0x00007f4fc09d0000]\n   java.lang.Thread.State: RUNNABLE\n        at java.lang.Throwable.getStackTraceElement(Native Method)\n        at java.lang.Throwable.getOurStackTrace(Throwable.java:827)\n        - locked <0x00000000faf1f990> (a java.lang.Throwable)\n        at java.lang.Throwable.getStackTrace(Throwable.java:816)\n        at sun.reflect.GeneratedMethodAccessor2.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:497)\n        at org.apache.log4j.spi.LocationInfo.<init>(LocationInfo.java:139)\n        at org.apache.log4j.spi.LoggingEvent.getLocationInformation(LoggingEvent.java:253)\n        at org.apache.log4j.pattern.LineLocationPatternConverter.format(LineLocationPatternConverter.java:58)\n        at org.apache.log4j.pattern.BridgePatternConverter.format(BridgePatternConverter.java:119)\n        at org.apache.log4j.EnhancedPatternLayout.format(EnhancedPatternLayout.java:546)\n        at org.apache.log4j.WriterAppender.subAppend(WriterAppender.java:310)\n        at org.apache.log4j.WriterAppender.append(WriterAppender.java:162)\n        at org.apache.log4j.AppenderSkeleton.doAppend(AppenderSkeleton.java:251)\n        - locked <0x00000000e00a2d40> (a org.apache.log4j.ConsoleAppender)\n        at org.apache.log4j.helpers.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:66)\n        at org.apache.log4j.Category.callAppenders(Category.java:206)\n        - locked <0x00000000e009adf0> (a org.apache.log4j.Logger)\n        at org.apache.log4j.Category.forcedLog(Category.java:391)\n        at org.apache.log4j.Category.log(Category.java:856)\n\n"http-nio-40243-exec-392" #1211 daemon prio=5 os_prio=0 tid=0x00007f4fd8095000 nid=0xe2f waiting for monitor entry [0x00007f4fc0dd4000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n        at org.apache.log4j.Category.callAppenders(Category.java:204)\n        - waiting to lock <0x00000000e009adf0> (a org.apache.log4j.Logger)\n        at org.apache.log4j.Category.forcedLog(Category.java:391)\n        at org.apache.log4j.Category.log(Category.java:856)\n        at org.slf4j.impl.Log4jLoggerAdapter.debug(Log4jLoggerAdapter.java:230)\n        at com.navercorp.pinpoint.profiler.logging.Slf4jPLoggerAdapter.debug(Slf4jPLoggerAdapter.java:285)\n        at com.navercorp.pinpoint.plugin.redis.interceptor.ProtocolSendCommandAndReadMethodInterceptor.before(ProtocolSendCommandAndReadMethodInterceptor.java:71)\n')])])]),e("p",[a._v("线程解读：")]),a._v(" "),e("ol",[e("li",[a._v("线程名,“http-nio-40243-exec-393”")]),a._v(" "),e("li",[a._v("线程属性（如果是Daemon线程，会有Daemon标识，否则，什么都没有）")]),a._v(" "),e("li",[a._v("线程优先级，prio")]),a._v(" "),e("li",[a._v("java线程对应的本地线程的优先级os_prio")]),a._v(" "),e("li",[a._v("java线程标识tid")]),a._v(" "),e("li",[a._v("java线程对应的本地线程标识nid")]),a._v(" "),e("li",[a._v("线程状态（运行中、等待等）")]),a._v(" "),e("li",[a._v("线程的栈信息")]),a._v(" "),e("li",[a._v("线程锁信息")])]),a._v(" "),e("p",[a._v("从"),e("code",[a._v("- locked <0x00000000e009adf0> (a org.apache.log4j.Logger)")]),a._v("和"),e("code",[a._v("- waiting to lock <0x00000000e009adf0> (a org.apache.log4j.Logger)")]),a._v("可以看出：\n393线程占用了<0x00000000e009adf0>锁，而392线程正等待获取锁。")]),a._v(" "),e("p",[e("strong",[a._v("死锁案例")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('Found one Java-level deadlock:\n=============================\n"Thread-1":\n  waiting to lock monitor 0x00007f0134003ae8 (object 0x00000007d6aa2c98, a java.lang.Object),\n  which is held by "Thread-0"\n"Thread-0":\n  waiting to lock monitor 0x00007f0134006168 (object 0x00000007d6aa2ca8, a java.lang.Object),\n  which is held by "Thread-1"\n\nJava stack information for the threads listed above:\n===================================================\n"Thread-1":\n    at javaCommand.DeadLockclass.run(JStackDemo.java:40)\n    - waiting to lock <0x00000007d6aa2c98> (a java.lang.Object)\n    - locked <0x00000007d6aa2ca8> (a java.lang.Object)\n    at java.lang.Thread.run(Thread.java:745)\n"Thread-0":\n    at javaCommand.DeadLockclass.run(JStackDemo.java:27)\n    - waiting to lock <0x00000007d6aa2ca8> (a java.lang.Object)\n    - locked <0x00000007d6aa2c98> (a java.lang.Object)\n    at java.lang.Thread.run(Thread.java:745)\n\nFound 1 deadlock.\n')])])]),e("p",[a._v("可以看出两个线程互相等待导致死锁。")]),a._v(" "),e("h2",{attrs:{id:"查看当前java进程的信息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查看当前java进程的信息"}},[a._v("#")]),a._v(" 查看当前java进程的信息")]),a._v(" "),e("p",[a._v("jhsdb必须在jdk11及以上使用\nsudo jhsdb jmap --heap --pid xxx")]),a._v(" "),e("h2",{attrs:{id:"字节码工具-asmtools"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字节码工具-asmtools"}},[a._v("#")]),a._v(" 字节码工具 asmtools")]),a._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://wiki.openjdk.java.net/display/CodeTools/asmtools",target:"_blank",rel:"noopener noreferrer"}},[a._v("amstools"),e("OutboundLink")],1)])]),a._v(" "),e("h2",{attrs:{id:"jhsdb-hsdb"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jhsdb-hsdb"}},[a._v("#")]),a._v(" jhsdb hsdb")]),a._v(" "),e("blockquote",[e("p",[a._v("JDK 9加入的调试工具")])])])}),[],!1,null,null,null);t.default=r.exports}}]);