(window.webpackJsonp=window.webpackJsonp||[]).push([[304],{716:function(e,t,a){"use strict";a.r(t);var r=a(42),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),a("blockquote",[a("p",[e._v("由于项目中有必要实现定时任务的动态管理, 所以需要重新实现spring的@Scheduled"),a("br"),e._v("\n本文的spring版本是5.1.9.RELEASE")])]),e._v(" "),a("h1",{attrs:{id:"schedules"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#schedules"}},[e._v("#")]),e._v(" @Schedules")]),e._v(" "),a("p",[e._v("源码上的注释如下, 指明了Schedules相当于Scheduled的容器注解")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Container annotation that aggregates several {@link Scheduled} annotations.\n<p>Can be used natively, declaring several nested {@link Scheduled} annotations.\nCan also be used in conjunction with Java 8's support for repeatable annotations,\nwhere {@link Scheduled} can simply be declared several times on the same method,\nimplicitly generating this container annotation.\n")])])]),a("h1",{attrs:{id:"scheduled的参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scheduled的参数"}},[e._v("#")]),e._v(" @Scheduled的参数")]),e._v(" "),a("ol",[a("li",[e._v("cron()")])]),e._v(" "),a("blockquote",[a("p",[e._v("定时任务的cron表达式, 这里关于表达式的具体写法就不做赘述了.")])]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("fixedDelay()")])]),e._v(" "),a("blockquote",[a("p",[e._v("上次调用结束和下次调用开始中间的间隔时间, 单位ms")])]),e._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[e._v("fixedDelayString()")])]),e._v(" "),a("blockquote",[a("p",[e._v("与fixedDelay()相同, 并且解析方法不一样")])]),e._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[e._v("fixedRate()")])]),e._v(" "),a("blockquote",[a("p",[e._v("两次"),a("code",[e._v("开始")]),e._v("调用的间隔时间, 与fixedDelay不同.")])]),e._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[e._v("fixedRateString()")])]),e._v(" "),a("blockquote",[a("p",[e._v("同上")])]),e._v(" "),a("ol",{attrs:{start:"6"}},[a("li",[e._v("initialDelay()")])]),e._v(" "),a("blockquote",[a("p",[e._v("在第一次执行fixedRate任务之前, 延迟多少ms")])]),e._v(" "),a("ol",{attrs:{start:"7"}},[a("li",[e._v("initialDelayString()")])]),e._v(" "),a("blockquote",[a("p",[e._v("同上")])]),e._v(" "),a("h1",{attrs:{id:"scheduledannotationbeanpostprocessor-如何实现定时任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scheduledannotationbeanpostprocessor-如何实现定时任务"}},[e._v("#")]),e._v(" ScheduledAnnotationBeanPostProcessor 如何实现定时任务")]),e._v(" "),a("blockquote",[a("p",[e._v("spring的定时任务是由此类实现")])]),e._v(" "),a("h2",{attrs:{id:"继承类的探秘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承类的探秘"}},[e._v("#")]),e._v(" 继承类的探秘")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("ScheduledTaskHolder")])]),e._v(" "),a("li",[a("p",[e._v("MergedBeanDefinitionPostProcessor")])]),e._v(" "),a("li",[a("p",[e._v("DestructionAwareBeanPostProcessor")])])]),e._v(" "),a("h2",{attrs:{id:"类中方法的探秘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类中方法的探秘"}},[e._v("#")]),e._v(" 类中方法的探秘")]),e._v(" "),a("ol",[a("li",[e._v("ScheduledAnnotationBeanPostProcessor的构造方法")])]),e._v(" "),a("blockquote",[a("p",[e._v("本类的构造方法有两个, 都是为了创建一个ScheduledTaskRegistrar类, 无参构造是直接new, 有参构造是由外部传入.")])]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("getOrder()")])]),e._v(" "),a("blockquote",[a("p",[e._v("此方法实现org.springframework.core的Ordered接口方法"),a("br"),e._v("\n设置低优先级")])]),e._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[e._v("setScheduler(Object scheduler)")])]),e._v(" "),a("blockquote",[a("p",[e._v("设置要执行的任务对象, 可以是"),a("code",[e._v("TaskScheduler")]),e._v(", 或者用"),a("code",[e._v("ScheduledExecutorService")])])]),e._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[e._v("setEmbeddedValueResolver(StringValueResolver resolver)")])]),e._v(" "),a("blockquote",[a("p",[e._v("实现自org.springframework.context.EmbeddedValueResolverAware接口的方法 "),a("br"),e._v("\n用于注入"),a("code",[e._v("StringValueResolver")]),e._v("来解析字符串")])]),e._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[e._v("setBeanName(String beanName)")])]),e._v(" "),a("blockquote",[a("p",[e._v("实现自org.springframework.beans.factory.BeanNameAware接口的方法 "),a("br"),e._v("\n在创建bean的容器中设置bean的名称")])]),e._v(" "),a("ol",{attrs:{start:"6"}},[a("li",[e._v("setBeanFactory(BeanFactory beanFactory)")])]),e._v(" "),a("blockquote",[a("p",[e._v("实现自org.springframework.beans.factory.BeanFactoryAware接口的方法"),a("br"),e._v("\n设置是可选的, 如果不设置则不会自动检测SchedulingConfigurer")])]),e._v(" "),a("ol",{attrs:{start:"7"}},[a("li",[e._v("setApplicationContext(ApplicationContext applicationContext)")])]),e._v(" "),a("blockquote",[a("p",[e._v("可选设置, 如果设置, 任务将在ContextRefreshedEvent阶段被激活; 如果未设置, 则任务激活将在afterSingletonsInstantiated时.")])]),e._v(" "),a("ol",{attrs:{start:"8"}},[a("li",[e._v("afterSingletonsInstantiated()")])]),e._v(" "),a("blockquote",[a("p",[e._v("移除缓存中被解决的单例classes,")])]),e._v(" "),a("ol",{attrs:{start:"9"}},[a("li",[a("p",[e._v("onApplicationEvent(ContextRefreshedEvent event)")])]),e._v(" "),a("li",[a("p",[e._v("finishRegistration()")])]),e._v(" "),a("li",[a("p",[e._v("resolveSchedulerBean(BeanFactory beanFactory, Class"),a("T",[e._v(" schedulerType, boolean byName)")])],1)])]),e._v(" "),a("h2",{attrs:{id:"解读相关类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解读相关类"}},[e._v("#")]),e._v(" 解读相关类")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("TaskScheduler")])]),e._v(" "),a("li",[a("p",[e._v("ScheduledExecutorService")])]),e._v(" "),a("li",[a("p",[e._v("SchedulingConfigurer")])]),e._v(" "),a("li",[a("p",[e._v("ContextRefreshedEvent")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("官方注释\nEvent raised when an {@code ApplicationContext} gets initialized or refreshed.\n")])])]),a("blockquote",[a("p",[e._v("ApplicationContext被初始化或刷新时, 引发此事件")])]),e._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[e._v("SmartInitializingSingleton")])]),e._v(" "),a("h2",{attrs:{id:"如何启动的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何启动的"}},[e._v("#")]),e._v(" 如何启动的")]),e._v(" "),a("h2",{attrs:{id:"如何扫描"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何扫描"}},[e._v("#")]),e._v(" 如何扫描")])])}),[],!1,null,null,null);t.default=s.exports}}]);