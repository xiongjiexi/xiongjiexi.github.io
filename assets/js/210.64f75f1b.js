(window.webpackJsonp=window.webpackJsonp||[]).push([[210],{622:function(t,s,a){"use strict";a.r(s);var n=a(42),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),a("blockquote",[a("p",[t._v("CPU, 内存, IO设备是计算机三个重要的组成, 性能好坏也由它们协调所致.")]),t._v(" "),a("p",[t._v("为了平衡三者速度的差异:")]),t._v(" "),a("ol",[a("li",[t._v("CPU上增加了缓存, 以均衡内存.")]),t._v(" "),a("li",[t._v("操作系统增加了进程/线程, 以均衡CPU和IO")]),t._v(" "),a("li",[t._v("编译器优化指令执行次序, 使缓存能更合理的利用")])])]),t._v(" "),a("h1",{attrs:{id:"可见性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可见性"}},[t._v("#")]),t._v(" 可见性")]),t._v(" "),a("blockquote",[a("p",[t._v("释义: 一个线程对共享变量的修改, 另一个线程能够马上看见.")]),t._v(" "),a("p",[t._v("在单核情况下, 所有线程都是操作同一个CPU缓存, 内存中数据只需要与CPU缓存保持一致就 不存在"),a("code",[t._v("可见性问题")]),t._v(".\n而多核情况下,  每颗CPU都有自己独立的缓存, 此时内存中的数据要与CPU缓存保持一致性就有困难了.")])]),t._v(" "),a("h1",{attrs:{id:"原子性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原子性"}},[t._v("#")]),t._v(" 原子性")]),t._v(" "),a("blockquote",[a("p",[t._v("一个或多个操作在CPU执行的过程中不会被中断的特性称为原子性.")]),t._v(" "),a("p",[t._v("CPU能保证的原子操作是CPU指令级别的, 而不是高级语言的最小操作单元.")])]),t._v(" "),a("h3",{attrs:{id:"并发场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发场景"}},[t._v("#")]),t._v(" 并发场景")]),t._v(" "),a("blockquote",[a("p",[t._v("下面是count+=1的场景, 两个线程同时执行.")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Thread A")]),t._v(" "),a("th",[t._v("Thread B")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("count=0加载到线程寄存器中")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("线程切换---\x3e")]),t._v(" "),a("td",[t._v("count=0加载到线程寄存器中")])]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td",[t._v("count+1=1")])]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td",[t._v("count=1写入内存")])]),t._v(" "),a("tr",[a("td",[t._v("count+1=1")]),t._v(" "),a("td",[t._v("<---线程切换")])]),t._v(" "),a("tr",[a("td",[t._v("count=1写入内存")]),t._v(" "),a("td")])])]),t._v(" "),a("h1",{attrs:{id:"有序性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有序性"}},[t._v("#")]),t._v(" 有序性")]),t._v(" "),a("blockquote",[a("p",[t._v("编译器为了优化性能, 有时候会改变程序中语句的先后顺序.")]),t._v(" "),a("p",[t._v("大多数顺序的优化都不会影响程序执行的结果, 但偶尔会出现意想不到的Bug.")])]),t._v(" "),a("h3",{attrs:{id:"场景重现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景重现"}},[t._v("#")]),t._v(" 场景重现")]),t._v(" "),a("blockquote",[a("p",[t._v("下面这个例子是"),a("code",[t._v("双重检查锁")]),t._v("实现单例模式, 在编译器优化的代码的过程中, 可能会出现"),a("code",[t._v("指令重排")]),t._v(".")]),t._v(" "),a("p",[t._v("但是我没有重现出来- -!")])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" instance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getInstance")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("instance "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("instance "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    instance "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" instance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("blockquote",[a("p",[a("strong",[t._v("场景说明")])]),t._v(" "),a("p",[t._v("两个线程A,B, A先进入synchronized同步块, 但是在new对象的时候发生了指令重排.\nnew本身会发生三个步骤, 1分配内存空间, 2初始化Singleton对象, 3将内存空间地址赋值给instance变量.\n此处指令重排是将步骤2和3顺序改成了先执行3后执行2, 如果线程切换发生在执行3之后执行2之前, 此时线程B获得时间片, 判断第一个if, instance变量是!=null的, 所以直接return instance, 但instance变量中的地址指向的内存空间实际上是没有被初始化的, 也就是线程B可能接下来执行的逻辑会出现NPE.")]),t._v(" "),a("p",[a("strong",[t._v("解决方案")])]),t._v(" "),a("p",[t._v("使用volatile修饰instance变量, 会禁止编译器指令重排.")])])])}),[],!1,null,null,null);s.default=e.exports}}]);