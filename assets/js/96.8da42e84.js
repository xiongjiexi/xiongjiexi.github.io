(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{498:function(t,a,s){"use strict";s.r(a);var r=s(42),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"从同事重构代码中学到的知识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从同事重构代码中学到的知识"}},[t._v("#")]),t._v(" 从同事重构代码中学到的知识")]),t._v(" "),s("h2",{attrs:{id:"代码中使用了-postconstruct注解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码中使用了-postconstruct注解"}},[t._v("#")]),t._v(" 代码中使用了@PostConstruct注解")]),t._v(" "),s("blockquote",[s("p",[t._v("@PostConstruct是javax.annotation.PostConstruct, 从Java EE5规范开始加入的注解,\n同时加入的还有@PreDestroy")])]),t._v(" "),s("p",[t._v("大家都比较清楚servlet的运行, 构造方法后就会执行init().而@PostConstruct是在构造方法之后, init()方法之前执行.\n总结如下:")]),t._v(" "),s("ol",[s("li",[t._v("@PostConstruct的执行顺序, 在构造方法之后.")]),t._v(" "),s("li",[t._v("在spring中, @Autowired同样在构造方法之后执行, 此时的顺序是: Construct > @Autowired > @PostConstruct")])]),t._v(" "),s("h2",{attrs:{id:"责任链模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#责任链模式"}},[t._v("#")]),t._v(" 责任链模式")]),t._v(" "),s("p",[s("strong",[t._v("1. 理解")]),t._v("\n首先可以看到责任链中的"),s("code",[t._v("链")]),t._v("字, 这告诉了你这种模式是链式的, 所有的"),s("code",[t._v("具体责任对象")]),t._v("共用一个"),s("code",[t._v("事件")]),t._v(", 并且会在某一个具体责任对象处终止.\n同时责任对象的顺序是可以随意设定的.")]),t._v(" "),s("p",[s("strong",[t._v("2. 特点")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1. 链式结构\n2. 调用方不清楚会在哪一处进行处理\n3. 最终只有一处会处理并终止\n")])])]),s("p",[s("strong",[t._v("3. 代码示意")]),t._v("\nJava诠释责任链模式需要3类对象:")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1. \n2. \n")])])]),s("p",[s("strong",[t._v("4. 理解")]),t._v("\n首先要了解清楚:")]),t._v(" "),s("ol",[s("li",[t._v("抽象类")])]),t._v(" "),s("blockquote",[s("p",[t._v("可以将公共的内容写到自己这里, 将与自己不同的内容写入到子类中.")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("链")])]),t._v(" "),s("blockquote",[s("p",[t._v("既然是链, 就有链共同的特性, 自身包含了指向下一个节点的方式.\n因此, 在抽象方法中需要定义一个next(), 用于指向下一个节点.")])]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("递归")])]),t._v(" "),s("blockquote",[s("p",[t._v("责任链模式中存在递归, 因为是链式调用, 调用深入后, 一定会逆向返回.")])]),t._v(" "),s("h2",{attrs:{id:"模板模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模板模式"}},[t._v("#")]),t._v(" 模板模式")]),t._v(" "),s("h2",{attrs:{id:"策略模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#策略模式"}},[t._v("#")]),t._v(" 策略模式")]),t._v(" "),s("h2",{attrs:{id:"functionalinterface"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#functionalinterface"}},[t._v("#")]),t._v(" @FunctionalInterface")]),t._v(" "),s("h2",{attrs:{id:"函数式编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程"}},[t._v("#")]),t._v(" 函数式编程")]),t._v(" "),s("blockquote",[s("p",[t._v("lambad表达式就属于函数式编程, 而函数式接口中规定只能有一个抽象方法定义, 也正是符合lambda的使用.")])]),t._v(" "),s("h2",{attrs:{id:"q-a"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-a"}},[t._v("#")]),t._v(" Q&A")]),t._v(" "),s("ol",[s("li",[t._v("为什么接口中可以存在default修饰的方法")]),t._v(" "),s("li")])])}),[],!1,null,null,null);a.default=e.exports}}]);