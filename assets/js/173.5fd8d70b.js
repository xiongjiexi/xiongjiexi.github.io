(window.webpackJsonp=window.webpackJsonp||[]).push([[173],{581:function(t,a,r){"use strict";r.r(a);var e=r(42),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"为什么是不可变对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么是不可变对象"}},[t._v("#")]),t._v(" 为什么是不可变对象")]),t._v(" "),r("blockquote",[r("p",[t._v("immutable是一种约定, 设计师将String设计为immutable是为了给程序带来更多的便利")])]),t._v(" "),r("h1",{attrs:{id:"string是如何设计的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#string是如何设计的"}},[t._v("#")]),t._v(" String是如何设计的")]),t._v(" "),r("h3",{attrs:{id:"成员变量皆为final修饰"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#成员变量皆为final修饰"}},[t._v("#")]),t._v(" 成员变量皆为final修饰")]),t._v(" "),r("blockquote",[r("p",[t._v("不给修改成员变量的机会")])]),t._v(" "),r("h3",{attrs:{id:"所有方法的设计都规避暴露成员变量的可能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#所有方法的设计都规避暴露成员变量的可能"}},[t._v("#")]),t._v(" 所有方法的设计都规避暴露成员变量的可能")]),t._v(" "),r("blockquote",[r("p",[t._v("这是设计实现上做到")])]),t._v(" "),r("h3",{attrs:{id:"类定义为final"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类定义为final"}},[t._v("#")]),t._v(" 类定义为final")]),t._v(" "),r("blockquote",[r("p",[t._v("因为约定为immutable, 因此为了避免他人打破约定, 直接将类定义为final.\n否则, 假设你继承String实现一个StringChild, 重写其中某一个方法, 在之后调用此方法传入StringChild时, 则会打破这种约定.")])]),t._v(" "),r("h1",{attrs:{id:"immutable的设计规则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#immutable的设计规则"}},[t._v("#")]),t._v(" immutable的设计规则")]),t._v(" "),r("ol",[r("li",[r("strong",[t._v("不要提供任何会修改对象状态的方法")])]),t._v(" "),r("li",[r("strong",[t._v("保证类不会被扩展")])]),t._v(" "),r("li",[r("strong",[t._v("使所有的域都是final")])]),t._v(" "),r("li",[r("strong",[t._v("使所有的域都成为私有的")])]),t._v(" "),r("li",[r("strong",[t._v("确保对于任何可变组件的互斥访问")])])]),t._v(" "),r("h1",{attrs:{id:"string类设计为不可变的好处"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#string类设计为不可变的好处"}},[t._v("#")]),t._v(" String类设计为不可变的好处")]),t._v(" "),r("h3",{attrs:{id:"线程安全"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程安全"}},[t._v("#")]),t._v(" 线程安全")]),t._v(" "),r("blockquote",[r("p",[t._v("在原子性上, String是安全的, 但在使用上, 还得注意"),r("code",[t._v("可见性")]),t._v(", 因此绝对说线程安全也是不对的, "),r("strong",[t._v("还需要保证其可见性")])])]),t._v(" "),r("h3",{attrs:{id:"效率"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#效率"}},[t._v("#")]),t._v(" 效率")]),t._v(" "),r("blockquote",[r("p",[t._v("设计成final，jvm才不用对相关方法在虚函数表中查询，而是直接定位到String类的相关方法上，提高执行效率")])]),t._v(" "),r("h1",{attrs:{id:"字符串常量池是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池是什么"}},[t._v("#")]),t._v(" 字符串常量池是什么")]),t._v(" "),r("blockquote",[r("p",[t._v("字符串常量池是方法区(Method Area)中一个特殊的存储区域, String被创建时, 如果值存在于String pool中, 则直接取出, 而不用创建新对象.\n在应用程序大量使用String的情况下, 可以节省内存空间, 提高效率.")])]),t._v(" "),r("h1",{attrs:{id:"immutable的优点和缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#immutable的优点和缺点"}},[t._v("#")]),t._v(" immutable的优点和缺点")]),t._v(" "),r("h3",{attrs:{id:"优点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),r("ol",[r("li",[r("strong",[t._v("不可变类对象比较简单")]),t._v("。不可变对象可以只有一种状态，即被创建时的状态")]),t._v(" "),r("li",[r("strong",[t._v("不可变对象本质上是线程安全的，它们不要求同步")]),t._v("。当多个线程并发访问这样的对象时，它们不会遭到破坏。实际上，没有任何线程会注意到其他线程对于不可变对象的影响。所以，"),r("strong",[t._v("不可变对象可以被自由地分配")]),t._v("。“不可变对象可以被自由地分配”导致的结果是：永远不需要进行保护性拷贝")]),t._v(" "),r("li",[r("strong",[t._v("不仅可以共享不可变对象，甚至也可以共享它们的内部信息")]),t._v("。")]),t._v(" "),r("li",[r("strong",[t._v("不可变对象为其他对象提供了大量的构件")]),t._v("。如果知道一个复杂对象内部的组件不会改变，要维护它的不变性约束是比较容易的。")])]),t._v(" "),r("h3",{attrs:{id:"缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),r("p",[r("strong",[t._v("对于每个不同的值都需要一个单独的对象")]),t._v("。创建这种对象的代价很高。")]),t._v(" "),r("h1",{attrs:{id:"java还有哪些immutable类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java还有哪些immutable类"}},[t._v("#")]),t._v(" Java还有哪些immutable类")]),t._v(" "),r("h3",{attrs:{id:"所有的包装类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#所有的包装类"}},[t._v("#")]),t._v(" 所有的包装类")]),t._v(" "),r("h3",{attrs:{id:"biginteger-bigdecimal"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#biginteger-bigdecimal"}},[t._v("#")]),t._v(" BigInteger,BigDecimal")]),t._v(" "),r("h1",{attrs:{id:"关于immutable的注意事项"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#关于immutable的注意事项"}},[t._v("#")]),t._v(" 关于Immutable的注意事项")]),t._v(" "),r("h3",{attrs:{id:"可以通过反射机制改变成员变量的值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可以通过反射机制改变成员变量的值"}},[t._v("#")]),t._v(" 可以通过反射机制改变成员变量的值")]),t._v(" "),r("h1",{attrs:{id:"参考地址"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考地址"}},[t._v("#")]),t._v(" 参考地址")]),t._v(" "),r("ol",[r("li",[r("a",{attrs:{href:"https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Why String is immutable in Java?"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.zhihu.com/question/31345592",target:"_blank",rel:"noopener noreferrer"}},[t._v("知乎回答"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/one_Jachen/article/details/78148606",target:"_blank",rel:"noopener noreferrer"}},[t._v("String类不可变以及不可变类总结"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=s.exports}}]);